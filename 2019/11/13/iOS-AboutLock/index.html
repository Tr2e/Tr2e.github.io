<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="iOS," />










<meta name="description" content="前言对于iOS中各种锁的学习总结，供日后查阅">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS-关于锁的总结">
<meta property="og:url" content="http://yoursite.com/2019/11/13/iOS-AboutLock/index.html">
<meta property="og:site_name" content="Tr2e&#39;s Blog">
<meta property="og:description" content="前言对于iOS中各种锁的学习总结，供日后查阅">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1742463-2acd56eaea585c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/1742463-ae8eb41b371e5c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="article:published_time" content="2019-11-13T14:18:18.000Z">
<meta property="article:modified_time" content="2020-03-28T03:50:18.183Z">
<meta property="article:author" content="Tr2e">
<meta property="article:tag" content="iOS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/1742463-2acd56eaea585c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/11/13/iOS-AboutLock/"/>





  <title>iOS-关于锁的总结 | Tr2e's Blog</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Tr2e's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/13/iOS-AboutLock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Tr2e">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tr2e's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">iOS-关于锁的总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-13T22:18:18+08:00">
                2019-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于iOS中各种锁的学习总结，供日后查阅</p>
<a id="more"></a>

<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>日常开发中，<code>@property (nonatomic, strong) *foo</code>是我们不厌其烦的使用频率最高的声明方式，也很清楚<code>atomic</code>和<code>nonatomic</code>属性的区别，这里再复习一下这两个关键字：</p>
<ul>
<li><code>atomic</code>:原子性，这个属性是默认的，通过在<code>setter</code>、<code>getter</code>中加锁保证数据的读写安全</li>
<li><code>nonatomic</code>:非原子性，就是不加锁。优点是速度优于使用<code>atomic</code>，大多数场景不会出现问题</li>
</ul>
<p>作为编译器标识符，<code>@property</code>的作用是帮助我们快速生成<em>成员变量及其getter/setter</em>方法，并通过属性关键字，帮助我们管理内存及安全等繁杂的事务，那么<code>atomic</code>是如何帮助我们保证成员变量的读写安全呢？下面我们看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@property(retain) UITextField *userName;</span><br><span class="line">&#x2F;&#x2F;示例代码如下：</span><br><span class="line">- (UITextField *) userName &#123;</span><br><span class="line">    UITextField *retval &#x3D; nil;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        retval &#x3D; [userName retain];</span><br><span class="line">        _userName &#x3D; retval;</span><br><span class="line">    &#125;</span><br><span class="line">    return retval;</span><br><span class="line">&#125;</span><br><span class="line">- (void) setUserName:(UITextField *)userName &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">      [_userName release];</span><br><span class="line">      _userName &#x3D; [userName retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以很容易的看出，编译器是通过加锁，来保证当前成员变量<code>_userName</code>的读写安全，不至于生成脏数据，这便是<code>atomic</code>背后，编译器帮我们做的事情。事实上，如果深究下去编译器帮我们加了什么锁，其实并非<code>@synchronized(object)</code></p>
<blockquote>
<p><em>自旋锁</em>不会使线程状态发生切换，一直处于用户态，即线程一直都是active；不会使线程进入阻塞状态，减少了不必要的上下文切换，执行速度快<br><em>非自旋锁</em>在获取不到锁的时候会进入阻塞状态，从而进入内核态，当获取到锁的时候需要从内核态恢复，需要线程上下文切换,影响锁的性能</p>
</blockquote>
<p>为什么<code>atomic</code>会做为默认属性，我们不难看出，苹果这么设计是想告诉我们，很多情况下，效率换安全是值得的</p>
<h2 id="如何使用锁"><a href="#如何使用锁" class="headerlink" title="如何使用锁"></a>如何使用锁</h2><p>下面一段简单代码，考虑一下输出结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)unlockTest &#123;</span><br><span class="line">    NSMutableString *string &#x3D; [@&quot;Mike&quot; mutableCopy];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        [string appendString:@&quot;-Locked&quot;];</span><br><span class="line">        NSLog(@&quot;%@&quot;,string);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [string appendString:@&quot;-JailBreaked&quot;];</span><br><span class="line">        NSLog(@&quot;%@&quot;,string);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>书写这样一段代码，是想在不同线程中在改变变量后，使用这个变量</p>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-11-11 16:52:43.019128+0800 DiscoverLock_iOS[89763:11225442] Mike-Locked-JailBreaked</span><br><span class="line">2019-11-11 16:52:43.019128+0800 DiscoverLock_iOS[89763:11225441] Mike-Locked-JailBreaked</span><br></pre></td></tr></table></figure>
<p>这显然不是想要的结果，如何保证我们在不同线程中使用的变量，都是我们希望的值呢？答案之一，就是加锁</p>
<h3 id=""><a href="#" class="headerlink" title=""></a><NSLocking></h3><p>OC为我们提供了四种遵循<NSLocking>的类，分别是<code>NSLock</code>/<code>NSCondtionLock</code>/<code>NSRecursiveLock</code>/<code>NSCondition</code>，满足面向对象编程的需求</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@protocol NSLocking</span><br><span class="line"></span><br><span class="line">- (void)lock;&#x2F;&#x2F; 阻塞线程，线程休眠</span><br><span class="line">- (void)unlock;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p><strong>加锁的基本流程： 【加锁】-&gt;【操作】-&gt;【解锁】</strong><br>以上提到的4个类，均可以实现这个基础功能，下文中不再赘述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)lockedTest &#123;</span><br><span class="line">    NSMutableString *string &#x3D; [@&quot;Mike&quot; mutableCopy];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        &#x2F;&#x2F; [锁 lock];</span><br><span class="line">        [string appendString:@&quot;-Locked&quot;];</span><br><span class="line">        NSLog(@&quot;%@&quot;,string);</span><br><span class="line">        &#x2F;&#x2F; [锁 unlock];</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        &#x2F;&#x2F; [锁 lock];</span><br><span class="line">        [string appendString:@&quot;-JailBreaked&quot;];</span><br><span class="line">        NSLog(@&quot;%@&quot;,string);</span><br><span class="line">        &#x2F;&#x2F; [锁 unlock];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DiscoverLock_iOS[90562:11303793] Mike-Locked</span><br><span class="line">DiscoverLock_iOS[90562:11303799] Mike-Locked-JailBreaked</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DiscoverLock_iOS[90562:11303793] Mike-JailBreaked</span><br><span class="line">DiscoverLock_iOS[90562:11303799] Mike-JailBreaked-Locked</span><br></pre></td></tr></table></figure>

<p>这里的输出，结果不太一样，侧面说明了<code>DISPATCH_QUEUE_PRIORITY</code>并不能保证线程的执行顺序，如果要明确执行顺序，属于线程同步的范畴，本文不展开讨论，只会在<strong>NSConditionLock</strong>部分简单示例如何使用该类做到同步</p>
<h4 id="NSLock"><a href="#NSLock" class="headerlink" title="NSLock"></a>NSLock</h4><ul>
<li><code>- (BOOL)tryLock;</code>:尝试加锁，如果失败返回NO，不会阻塞线程</li>
<li><code>- (BOOL)lockBeforeDate:(NSDate *)limit;</code>:指定时间前尝试加锁，如果失败返回NO，到时间前阻塞线程</li>
</ul>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (void)lockTest &#123;</span><br><span class="line"></span><br><span class="line">    NSMutableString *string &#x3D; [@&quot;Mike&quot; mutableCopy];</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">    LOCK(</span><br><span class="line">         [string appendString:@&quot;-Locked&quot;];</span><br><span class="line">         NSLog(@&quot;%@&quot;,string);</span><br><span class="line">         sleep(5);</span><br><span class="line">        )</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">    TRYLOCK(</span><br><span class="line">            [string appendString:@&quot;-UnLock&quot;];</span><br><span class="line">            NSLog(@&quot;%@&quot;,string);</span><br><span class="line">            sleep(3);</span><br><span class="line">        )</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">    TRYLOCKINDURATION(2,</span><br><span class="line">                      [string appendString:@&quot;-Ending&quot;];</span><br><span class="line">                      NSLog(@&quot;%@&quot;,string);</span><br><span class="line">                      );</span><br><span class="line">    NSLog(@&quot;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2019-11-11 19:54:08.807763+0800 DiscoverLock_iOS[92986:11465678] Mike-Locked</span><br><span class="line">2019-11-11 19:54:08.807763+0800 DiscoverLock_iOS[92986:11465679] TryLock-NO</span><br><span class="line">2019-11-11 19:54:08.807889+0800 DiscoverLock_iOS[92986:11465679] Mike-Locked-UnLock</span><br><span class="line">2019-11-11 19:54:10.810165+0800 DiscoverLock_iOS[92986:11465677] TryLockBefore-NO</span><br><span class="line">2019-11-11 19:54:10.810523+0800 DiscoverLock_iOS[92986:11465677] Mike-Locked-UnLock-Ending</span><br><span class="line">2019-11-11 19:54:10.810810+0800 DiscoverLock_iOS[92986:11465677] -&#x3D;-&#x3D;-&#x3D;-&#x3D;-</span><br></pre></td></tr></table></figure>
<p>通过上面示例代码输出可以看到，<code>- (BOOL)tryLock;</code>并不会阻塞线程，在尝试加锁失败时，立即返回了<strong>NO</strong>,但是<code>- (BOOL)lockBeforeDate:(NSDate *)limit;</code>则在时间到之前阻塞了线程操作，在等待相应时间后，返回了<strong>NO</strong>，并执行了下一句打印，很明显是在等待期间阻塞了线程</p>
<p>上面代码中用到的几个宏定义，建议以后使用锁时，尽量保持头脑清醒或者干脆定义一些便利方法，保证【上锁】-【解锁】的成对出现，避免线程阻塞或死锁的情况</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#define LOCK(...) \</span><br><span class="line">[_lock lock]; \</span><br><span class="line">__VA_ARGS__; \</span><br><span class="line">[_lock unlock]; \</span><br><span class="line"></span><br><span class="line">#define TRYLOCK(...) \</span><br><span class="line">BOOL locked &#x3D; [_lock tryLock]; \</span><br><span class="line">NSLog(@&quot;%@&quot;,locked?@&quot;TryLock-YES&quot;:@&quot;TryLock-NO&quot;); \</span><br><span class="line">__VA_ARGS__; \</span><br><span class="line">if (locked) [_lock unlock]; \</span><br><span class="line"></span><br><span class="line">#define TRYLOCKINDURATION(duration,...) \</span><br><span class="line">BOOL locked &#x3D; [_lock lockBeforeDate:[NSDate dateWithTimeIntervalSinceNow:duration]]; \</span><br><span class="line">NSLog(@&quot;%@&quot;,locked?@&quot;TryLockBefore-YES&quot;:@&quot;TryLockBefore-NO&quot;); \</span><br><span class="line">__VA_ARGS__; \</span><br><span class="line">if (locked) [_lock unlock]; \</span><br></pre></td></tr></table></figure>

<h4 id="NSConditionLock"><a href="#NSConditionLock" class="headerlink" title="NSConditionLock"></a>NSConditionLock</h4><ul>
<li><code>- (instancetype)initWithCondition:(NSInteger)condition NS_DESIGNATED_INITIALIZER;</code>:便利构造方法，传入条件锁的初始值</li>
<li><code>@property (readonly) NSInteger condition;</code>:当前条件锁的值</li>
<li><code>- (void)lockWhenCondition:(NSInteger)condition;</code>:当锁的条件值与传入值相等时，执行接下来的操作，否则阻塞线程</li>
<li><code>- (BOOL)tryLock;</code>:尝试加锁，如果失败返回NO，不会阻塞线程</li>
<li><code>- (BOOL)tryLockWhenCondition:(NSInteger)condition;</code>:尝试加锁，当锁的条件值与传入值相等，则加锁成功，否则失败返回NO，不会阻塞线程</li>
<li><code>- (void)unlockWithCondition:(NSInteger)condition;</code>:解锁操作，同时变更锁的条件值为传入值</li>
<li><code>- (BOOL)lockBeforeDate:(NSDate *)limit;</code>:指定时间前尝试加锁，如果失败返回NO，到时间前阻塞线程</li>
<li><code>- (BOOL)lockWhenCondition:(NSInteger)condition beforeDate:(NSDate *)limit;</code>:指定时间前尝试加锁，当锁的条件值与传入值相等，则加锁成功返回YES，否则失败返回NO，到时间前阻塞线程</li>
</ul>
<p><code>NSConditionLock</code>和<code>NSLock</code>方法类似，多了一个<code>condition</code>属性，以及每个操作都多了一个关于condition属性的方法，<code>- (void)lockWhenCondition:(NSInteger)condition;</code>只有condition参数与初始化时候的condition相等，lock才能正确进行加锁操作。而<code>- (void)unlockWithCondition:(NSInteger)condition;</code>并不是当条件值符合条件时才解锁，而是解锁之后,修改当前锁的条件值<br>假如不使用condition相关的方法，<code>NSConditionLock</code>同<code>NSLock</code>并无二致</p>
<p>上文中我们提到了线程同步问题，这里一起看一下下面这段代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">- (void)conditionLockUnordered &#123;</span><br><span class="line">    NSMutableString *conditionString &#x3D; [[NSMutableString alloc] init];</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [conditionString appendString:@&quot;-1-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 1 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [conditionString appendString:@&quot;-2-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 2 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [conditionString appendString:@&quot;-3-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 3 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [conditionString appendString:@&quot;-4-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 4 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [conditionString appendString:@&quot;-5-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 5 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-11-11 20:34:16.875479+0800 DiscoverLock_iOS[93895:11551560] &gt;&gt;&gt; 2 -1--2--4--3- threadInfo:&lt;NSThread: 0x600003905640&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:34:16.875525+0800 DiscoverLock_iOS[93895:11551562] &gt;&gt;&gt; 3 -1--2--4--3- threadInfo:&lt;NSThread: 0x600003903680&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:34:16.875530+0800 DiscoverLock_iOS[93895:11551561] &gt;&gt;&gt; 1 -1--2- threadInfo:&lt;NSThread: 0x600003908bc0&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:34:16.875543+0800 DiscoverLock_iOS[93895:11551559] &gt;&gt;&gt; 4 -1--2--4--3- threadInfo:&lt;NSThread: 0x6000039175c0&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:34:16.875628+0800 DiscoverLock_iOS[93895:11551560] &gt;&gt;&gt; 5 -1--2--4--3--5- threadInfo:&lt;NSThread: 0x600003905640&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br></pre></td></tr></table></figure>
<p>依然是混乱状态，上文中<code>NSLock</code>部分已经通过加锁，控制了读写的稳定性，那么如果我们想要按照标号依次执行，该如何操作？</p>
<p>熟悉<code>GCD</code>的小伙伴会说这还不简单，<code>dispatch_barrier</code>解千愁，当然这么写没问题，但是这里多说一嘴，<code>dispatch_barrier</code>只能针对同一个并发队列起作用，注意正确初始化的姿势<code>dispatch_queue_t thread = dispatch_queue_create(&quot;barrier&quot;, DISPATCH_QUEUE_CONCURRENT);</code>,而不是干啥都是一句<code>dispatch_get_global_queue(0,0)</code>,如果使用Global_Queue,这个barrier就同普通的<code>dispatch_async</code>没什么区别了</p>
<p>我们要是想在不同线程搞定顺序这个事儿，怎么办呢？这个时候<code>NSConditionLock</code>自带的条件方法，便能帮你实现这个功能，具体看下面的示例代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (void)conditionLockOrdered &#123;</span><br><span class="line">    &#x2F;&#x2F; NSConditionLock</span><br><span class="line">    NSInteger conditionTag &#x3D; 0;</span><br><span class="line">    _conditionLock &#x3D; [[NSConditionLock alloc] initWithCondition:conditionTag];</span><br><span class="line">    </span><br><span class="line">    NSMutableString *conditionString &#x3D; [[NSMutableString alloc] init];</span><br><span class="line">    </span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; handle 1 &lt;&lt;&lt;&quot;);</span><br><span class="line">        [_conditionLock lockWhenCondition:conditionTag];</span><br><span class="line">        [conditionString appendString:@&quot;-1-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 1 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">        [_conditionLock unlockWithCondition:1];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; handle 2 &lt;&lt;&lt;&quot;);</span><br><span class="line">        [_conditionLock lockWhenCondition:1];</span><br><span class="line">        [conditionString appendString:@&quot;-2-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 2 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">        [_conditionLock unlockWithCondition:2];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; handle 3 &lt;&lt;&lt;&quot;);</span><br><span class="line">        [_conditionLock lockWhenCondition:2];</span><br><span class="line">        [conditionString appendString:@&quot;-3-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 3 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">        [_conditionLock unlockWithCondition:3];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; handle 4 &lt;&lt;&lt;&quot;);</span><br><span class="line">        [_conditionLock lockWhenCondition:3];</span><br><span class="line">        [conditionString appendString:@&quot;-4-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 4 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">        [_conditionLock unlockWithCondition:4];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; handle 5 &lt;&lt;&lt;&quot;);</span><br><span class="line">        [_conditionLock lockWhenCondition:4];</span><br><span class="line">        [conditionString appendString:@&quot;-5-&quot;];</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; 5 %@ threadInfo:%@&lt;&lt;&lt;&quot;,conditionString,[NSThread currentThread]);</span><br><span class="line">        [_conditionLock  unlock];</span><br><span class="line">        NSLog(@&quot;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">    NSLog(@&quot;🍺&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">2019-11-11 20:53:58.237847+0800 DiscoverLock_iOS[94374:11586439] 🍺</span><br><span class="line">2019-11-11 20:53:58.237862+0800 DiscoverLock_iOS[94374:11586488] &gt;&gt;&gt; handle 1 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.237877+0800 DiscoverLock_iOS[94374:11586489] &gt;&gt;&gt; handle 3 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.237868+0800 DiscoverLock_iOS[94374:11586490] &gt;&gt;&gt; handle 2 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.237887+0800 DiscoverLock_iOS[94374:11586491] &gt;&gt;&gt; handle 4 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.237892+0800 DiscoverLock_iOS[94374:11586495] &gt;&gt;&gt; handle 5 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.238111+0800 DiscoverLock_iOS[94374:11586488] &gt;&gt;&gt; 1 -1- threadInfo:&lt;NSThread: 0x6000014c3380&gt;&#123;number &#x3D; 3, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.238488+0800 DiscoverLock_iOS[94374:11586490] &gt;&gt;&gt; 2 -1--2- threadInfo:&lt;NSThread: 0x6000014dac40&gt;&#123;number &#x3D; 4, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.238605+0800 DiscoverLock_iOS[94374:11586489] &gt;&gt;&gt; 3 -1--2--3- threadInfo:&lt;NSThread: 0x6000014daf00&gt;&#123;number &#x3D; 5, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.239269+0800 DiscoverLock_iOS[94374:11586491] &gt;&gt;&gt; 4 -1--2--3--4- threadInfo:&lt;NSThread: 0x6000014c6740&gt;&#123;number &#x3D; 6, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.239410+0800 DiscoverLock_iOS[94374:11586495] &gt;&gt;&gt; 5 -1--2--3--4--5- threadInfo:&lt;NSThread: 0x6000014c3480&gt;&#123;number &#x3D; 7, name &#x3D; (null)&#125;&lt;&lt;&lt;</span><br><span class="line">2019-11-11 20:53:58.239552+0800 DiscoverLock_iOS[94374:11586495] -&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-&#x3D;-</span><br></pre></td></tr></table></figure>
<p>可以看到，不同的线程，虽然被调度的时机不同，但是因为<code>NSConditionLock</code>的存在，后续对数据具体的操作，我们预想的顺序得到了保证。这种用法笔者并认为在任务耗时较少的情况下没有明显问题的，但是假如存在长时间的耗时操作，还是建议使用<code>dispatch_barrier</code>，因为这样不会占用过多资源</p>
<h4 id="NSRecursiveLock"><a href="#NSRecursiveLock" class="headerlink" title="NSRecursiveLock"></a>NSRecursiveLock</h4><ul>
<li><code>- (BOOL)tryLock;</code>:尝试加锁，如果失败返回NO，不会阻塞线程</li>
<li><code>- (BOOL)lockBeforeDate:(NSDate *)limit;</code>:指定时间前尝试加锁，如果失败返回NO，到时间前阻塞线程<br>Api同<code>NSLock</code>完全一样，区别在于<code>NSRecursiveLock（递归锁）</code>可以在同一线程中重复加锁而不死锁，它会记录【上锁】和【解锁】的次数，当这两个值平衡时，才会释放锁，其他线程才可以上锁成功</li>
</ul>
<p>先看下一段代码，会存在什么问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, assign) NSInteger recursiveNum;&#x2F;&#x2F; 5</span><br><span class="line">- (void)test_unrecursiveLock &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [self recursiveTest];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        self.recursiveNum &#x3D; 7;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; changed %ld &lt;&lt;&lt;&quot;,self.recursiveNum);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)recursiveTest &#123;</span><br><span class="line">    if (self.recursiveNum &gt; 0) &#123;</span><br><span class="line">        self.recursiveNum -&#x3D; 1;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; %ld &lt;&lt;&lt;&quot;,self.recursiveNum);</span><br><span class="line">        [self recursiveTest];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2019-11-11 21:27:13.451703+0800 DiscoverLock_iOS[95105:11645279] &gt;&gt;&gt; 4 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:27:13.451709+0800 DiscoverLock_iOS[95105:11645277] &gt;&gt;&gt; changed 7 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:27:13.451812+0800 DiscoverLock_iOS[95105:11645279] &gt;&gt;&gt; 6 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:27:13.451883+0800 DiscoverLock_iOS[95105:11645279] &gt;&gt;&gt; 5 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:27:13.451940+0800 DiscoverLock_iOS[95105:11645279] &gt;&gt;&gt; 4 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:27:13.452004+0800 DiscoverLock_iOS[95105:11645279] &gt;&gt;&gt; 3 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:27:13.452068+0800 DiscoverLock_iOS[95105:11645279] &gt;&gt;&gt; 2 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:27:13.452130+0800 DiscoverLock_iOS[95105:11645279] &gt;&gt;&gt; 1 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:27:13.452241+0800 DiscoverLock_iOS[95105:11645279] &gt;&gt;&gt; 0 &lt;&lt;&lt;</span><br></pre></td></tr></table></figure>
<p>同时存在两个线程，对已知的recursiveNum的值进行写操作，其中一个线程使用递归调用，对该值进行了操作，但是同时另一个线程改变了这个值，在不加锁的情况下，这种操作问题很多，如果递归中含有重要的逻辑处理，竞态可能导致整个逻辑执行完的结果大概率是错误的。</p>
<p>如何规避这种竞态导致的不必要的错误，首先我们想到的是加锁，但是如果递归加锁的话，线程会重复加锁，导致死锁。所以这时候必须使用<strong>递归锁</strong>来解决这个问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (void)test_unrecursiveLock &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">        [self recursiveTest];</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        [_recursiveLock lock];&#x2F;&#x2F; 递归锁</span><br><span class="line">        self.recursiveNum &#x3D; 7;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; changed %ld &lt;&lt;&lt;&quot;,self.recursiveNum);</span><br><span class="line">        [_recursiveLock unlock];&#x2F;&#x2F; 解锁</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (void)recursiveTest &#123;</span><br><span class="line">    [_recursiveLock lock];&#x2F;&#x2F; 递归锁</span><br><span class="line">    if (self.recursiveNum &gt; 0) &#123;</span><br><span class="line">        self.recursiveNum -&#x3D; 1;</span><br><span class="line">        NSLog(@&quot;&gt;&gt;&gt; %ld &lt;&lt;&lt;&quot;,self.recursiveNum);</span><br><span class="line">        [self recursiveTest];</span><br><span class="line">    &#125;</span><br><span class="line">    [_recursiveLock unlock];&#x2F;&#x2F; 解锁</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">2019-11-11 21:34:44.422337+0800 DiscoverLock_iOS[95341:11655990] &gt;&gt;&gt; 4 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:34:44.422442+0800 DiscoverLock_iOS[95341:11655990] &gt;&gt;&gt; 3 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:34:44.422511+0800 DiscoverLock_iOS[95341:11655990] &gt;&gt;&gt; 2 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:34:44.422583+0800 DiscoverLock_iOS[95341:11655990] &gt;&gt;&gt; 1 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:34:44.422645+0800 DiscoverLock_iOS[95341:11655990] &gt;&gt;&gt; 0 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:34:44.422747+0800 DiscoverLock_iOS[95341:11655992] &gt;&gt;&gt; changed 7 &lt;&lt;&lt;</span><br><span class="line"></span><br><span class="line">------</span><br><span class="line"></span><br><span class="line">2019-11-11 21:37:11.238448+0800 DiscoverLock_iOS[95396:11662426] &gt;&gt;&gt; changed 7 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:37:11.238635+0800 DiscoverLock_iOS[95396:11662423] &gt;&gt;&gt; 6 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:37:11.238793+0800 DiscoverLock_iOS[95396:11662423] &gt;&gt;&gt; 5 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:37:11.238930+0800 DiscoverLock_iOS[95396:11662423] &gt;&gt;&gt; 4 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:37:11.239093+0800 DiscoverLock_iOS[95396:11662423] &gt;&gt;&gt; 3 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:37:11.239293+0800 DiscoverLock_iOS[95396:11662423] &gt;&gt;&gt; 2 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:37:11.239844+0800 DiscoverLock_iOS[95396:11662423] &gt;&gt;&gt; 1 &lt;&lt;&lt;</span><br><span class="line">2019-11-11 21:37:11.239976+0800 DiscoverLock_iOS[95396:11662423] &gt;&gt;&gt; 0 &lt;&lt;&lt;</span><br></pre></td></tr></table></figure>
<p>虽然存在两种输出结果，但是我们的递归操作的逻辑，可以完全不受干扰，如果需要控制顺序，（敲黑板）要怎么做呢？</p>
<h4 id="NSCondition"><a href="#NSCondition" class="headerlink" title="NSCondition"></a>NSCondition</h4><ul>
<li><code>- (void)wait;</code>:当前线程立即进入休眠状态</li>
<li><code>- (BOOL)waitUntilDate:(NSDate *)limit;</code>:当前线程立即进入休眠状态，limit时间后唤醒</li>
<li><code>- (void)signal;</code>:唤醒wait后进入休眠的单条线程</li>
<li><code>- (void)broadcast;</code>:唤醒wait后进入休眠的所有线程，调度</li>
</ul>
<p>有些情况需要协调线程之间的执行。例如，一个线程可能需要等待其他线程返回结果，这个时候<code>NSCondition</code>可能是个好选择</p>
<p>为了能体现NSCondition的作用，我们举一个可能并不是很恰当的<strong>生产者-消费者</strong>的例子：<br><strong>我们现在有一条柔性生产线，限定每个批次只能生产3件商品，耗时6s，同时开放网络购买平台让大家抢购拼团，订单式销售，三人成团，现在有三位天选之子 <em>Tom/Mike/Lily</em> 从全球千万人中脱颖而出，成功成团。为了增强可玩性，活动是从开启的一刻起，同时开始生产和抢购，3件库存销售完成后，再次进行同时进行生产和抢购活动</strong></p>
<p>代码示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">@interface Producer : NSObject</span><br><span class="line">@property (nonatomic, assign) BOOL shouldProduce;</span><br><span class="line">@property (nonatomic, strong) NSString *itemName;</span><br><span class="line">@property (nonatomic, strong) NSCondition *condition;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *collector;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConditon:(NSCondition *)condition collector:(NSMutableArray *)collector;</span><br><span class="line">- (void)produce;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Producer</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithConditon:(NSCondition *)condition collector:(NSMutableArray *)collector&#123;</span><br><span class="line">    </span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.condition &#x3D; condition;</span><br><span class="line">        self.collector &#x3D; collector;</span><br><span class="line">        self.shouldProduce &#x3D; NO;</span><br><span class="line">        self.itemName &#x3D; nil;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)produce&#123;</span><br><span class="line">    self.shouldProduce &#x3D; YES;</span><br><span class="line">    while (self.shouldProduce) &#123;</span><br><span class="line">        NSLog(@&quot;准备生产&quot;);</span><br><span class="line">        [self.condition lock];</span><br><span class="line">        NSLog(@&quot;- p lock -&quot;);</span><br><span class="line">        if (self.collector.count &gt; 0 ) &#123;</span><br><span class="line">            NSLog(@&quot;- p - wait&quot;);</span><br><span class="line">            [self.condition wait];</span><br><span class="line">        &#125;</span><br><span class="line">        NSLog(@&quot;开始生产&quot;);</span><br><span class="line">        [self.collector addObject:@&quot;商品1&quot;];</span><br><span class="line">        [self.collector addObject:@&quot;商品2&quot;];</span><br><span class="line">        [self.collector addObject:@&quot;商品3&quot;];</span><br><span class="line">        NSLog(@&quot;生产:商品1&#x2F;商品2&#x2F;商品3&quot;);</span><br><span class="line">        sleep(6);</span><br><span class="line">        NSLog(@&quot;生产结束&quot;);</span><br><span class="line">        [self.condition broadcast];</span><br><span class="line">        NSLog(@&quot;- p signal -&quot;);</span><br><span class="line">        [self.condition unlock];</span><br><span class="line">        NSLog(@&quot;- p unlock -&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;-结束生产-&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@interface Consumer : NSObject</span><br><span class="line">@property (nonatomic, assign) BOOL shouldConsumer;</span><br><span class="line">@property (nonatomic, strong) NSCondition *condition;</span><br><span class="line">@property (nonatomic, strong) NSMutableArray *collector;</span><br><span class="line">@property (nonatomic,   copy) NSString *itemName;</span><br><span class="line">- (instancetype)initWithConditon:(NSCondition *)condition collector:(NSMutableArray *)collector name:(NSString *)name;</span><br><span class="line">- (void)consumer;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Consumer</span><br><span class="line">- (instancetype)initWithConditon:(NSCondition *)condition collector:(NSMutableArray *)collector name:(NSString *)name&#123;</span><br><span class="line">    self &#x3D; [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        self.condition &#x3D; condition;</span><br><span class="line">        self.collector &#x3D; collector;</span><br><span class="line">        self.shouldConsumer &#x3D; NO;</span><br><span class="line">        self.itemName &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(void)consumer&#123;</span><br><span class="line">    self.shouldConsumer &#x3D; YES;</span><br><span class="line">    while (self.shouldConsumer) &#123;</span><br><span class="line">        NSLog(@&quot;%@-准备购买&quot;,self.itemName);</span><br><span class="line">        [self.condition lock];</span><br><span class="line">        NSLog(@&quot;- c:%@ lock -&quot;,self.itemName);</span><br><span class="line">        if (self.collector.count &#x3D;&#x3D; 0 ) &#123;</span><br><span class="line">            NSLog(@&quot;- c:%@ wait -&quot;,self.itemName);</span><br><span class="line">            [self.condition wait];</span><br><span class="line">        &#125;</span><br><span class="line">        NSString *item &#x3D; [self.collector objectAtIndex:0];</span><br><span class="line">        NSLog(@&quot;%@-买入:%@&quot;,self.itemName,item);</span><br><span class="line">        [self.collector removeObjectAtIndex:0];</span><br><span class="line">        sleep(2);</span><br><span class="line">        [self.condition signal];</span><br><span class="line">        NSLog(@&quot;- c:%@ signal -&quot;,self.itemName);</span><br><span class="line">        [self.condition unlock];</span><br><span class="line">        NSLog(@&quot;- c:%@ unlock -&quot;,self.itemName);</span><br><span class="line">    &#125;</span><br><span class="line">    NSLog(@&quot;-%@结束购买-&quot;,self.itemName);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableArray *pipeline &#x3D; [NSMutableArray array];</span><br><span class="line">    NSCondition *condition &#x3D; [NSCondition new];</span><br><span class="line">    </span><br><span class="line">    Producer *p &#x3D; [[Producer alloc] initWithConditon:condition collector:pipeline];</span><br><span class="line">    Consumer *c &#x3D; [[Consumer alloc] initWithConditon:condition collector:pipeline name:@&quot;Tom&quot;];</span><br><span class="line">    Consumer *c1 &#x3D; [[Consumer alloc] initWithConditon:condition collector:pipeline name:@&quot;Mike&quot;];</span><br><span class="line">    Consumer *c2 &#x3D; [[Consumer alloc] initWithConditon:condition collector:pipeline name:@&quot;Lily&quot;];</span><br><span class="line">    [[[NSThread alloc] initWithTarget:c selector:@selector(consumer) object:c] start];</span><br><span class="line">    [[[NSThread alloc] initWithTarget:c1 selector:@selector(consumer) object:c] start];</span><br><span class="line">    [[[NSThread alloc] initWithTarget:c2 selector:@selector(consumer) object:c] start];</span><br><span class="line">    [[[NSThread alloc] initWithTarget:p selector:@selector(produce) object:p] start];</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    sleep(15);</span><br><span class="line">    NSLog(@&quot;&lt;-----------------&gt;&quot;);</span><br><span class="line">    p.shouldProduce &#x3D; NO;</span><br><span class="line">    c.shouldConsumer &#x3D; NO;</span><br><span class="line">    c1.shouldConsumer &#x3D; NO;</span><br><span class="line">    c2.shouldConsumer &#x3D; NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部分控制台输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2019-11-12 17:04:03.662926+0800 DiscoverLock_iOS[7110:12246052] Mike-准备购买</span><br><span class="line">2019-11-12 17:04:03.662916+0800 DiscoverLock_iOS[7110:12246051] Tom-准备购买</span><br><span class="line">2019-11-12 17:04:03.662990+0800 DiscoverLock_iOS[7110:12246053] Lily-准备购买</span><br><span class="line">2019-11-12 17:04:03.663005+0800 DiscoverLock_iOS[7110:12246054] 准备生产</span><br><span class="line">2019-11-12 17:04:03.663083+0800 DiscoverLock_iOS[7110:12246053] - c:Lily lock -</span><br><span class="line">2019-11-12 17:04:03.663144+0800 DiscoverLock_iOS[7110:12246053] - c:Lily wait -</span><br><span class="line">2019-11-12 17:04:03.663254+0800 DiscoverLock_iOS[7110:12246052] - c:Mike lock -</span><br><span class="line">2019-11-12 17:04:03.663439+0800 DiscoverLock_iOS[7110:12246052] - c:Mike wait -</span><br><span class="line">2019-11-12 17:04:03.663805+0800 DiscoverLock_iOS[7110:12246051] - c:Tom lock -</span><br><span class="line">2019-11-12 17:04:03.663903+0800 DiscoverLock_iOS[7110:12246051] - c:Tom wait -</span><br><span class="line">2019-11-12 17:04:03.664126+0800 DiscoverLock_iOS[7110:12246054] - p lock -</span><br><span class="line">2019-11-12 17:04:03.664297+0800 DiscoverLock_iOS[7110:12246054] 开始生产</span><br><span class="line">2019-11-12 17:04:03.664433+0800 DiscoverLock_iOS[7110:12246054] 生产:商品1&#x2F;商品2&#x2F;商品3</span><br><span class="line">2019-11-12 17:04:09.669735+0800 DiscoverLock_iOS[7110:12246054] 生产结束</span><br></pre></td></tr></table></figure>
<p>基于多线程并发的工作原理，通过上面的部分打印结果，也很容易得到这个结论。<strong>由于不符合购买条件</strong>，<em>Lily</em>/<em>Mike</em>/<em>Tom</em>都只能选择<code>wait</code>，这个时候，生产者获取到锁并执行生产代码，在生产完成后，<code>broadcast</code>或者<code>signal</code>告诉其他线程，可以唤醒线程并继续执行消费者相关代码。<br><code>NSCondition</code>相较于<code>NSConditionLock</code>的不同点在于他依赖的是外部值，能够满足更多复杂需求场景。<br>假如将上述代码中生产者的<code>broadcast</code>替换成<code>signal</code>后发现，在当前这种特定场景下，这两个方法的作用似乎并没有什么区别。而且感兴趣的同学，可以使用上述代码多运行几次，看看是否能够得出同笔者一样的猜测：</p>
<ol>
<li>NSCondition会自身通过队列管理协同任务的调度</li>
<li>wait的任务依次入等待队列</li>
<li>未wait的任务根据获得锁的顺序依次入执行队列</li>
<li>wait任务的等待队列会在执行队列执行完后依次执行并入执行队列</li>
<li>第一次调度顺序确定后，后续任务的执行，按照执行队列缓存依次出列执行<br>这里仅做猜想，具体实现可能并非如此，待大佬指点迷津或有机会鶸笔者自行研究</li>
</ol>
<h3 id="OSSpinLock"><a href="#OSSpinLock" class="headerlink" title="OSSpinLock"></a>OSSpinLock</h3><p>看了<code>NSCondition</code>这么个复杂的东西，我们看点轻松的，<code>OSSpinLock</code>是苹果在<strong>iOS10</strong>之前提供的自旋锁方案，但是存在优先级反转的问题，被苹果废弃，以前源码中使用<code>OSSpinLock</code>的地方，都被苹果替换成了<code>pthread_mutex</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/1742463-2acd56eaea585c78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="被废弃的OSSpinLock.png"><br><img src="https://upload-images.jianshu.io/upload_images/1742463-ae8eb41b371e5c62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="官方备注.png"></p>
<h3 id="os-unfair-lock"><a href="#os-unfair-lock" class="headerlink" title="os_unfair_lock"></a>os_unfair_lock</h3><p><code>os_unfair_lock</code>是<strong>iOS10</strong>以后新增的低级别加锁方案，本质是<strong>互斥锁</strong>，这里需要注意，目前很多文章认为他是作为替代<code>OSSpinLock</code>的方案就是自旋锁是有问题的</p>
<ul>
<li><code>void os_unfair_lock_lock(os_unfair_lock_t lock);</code>:加锁</li>
<li><code>bool os_unfair_lock_trylock(os_unfair_lock_t lock);</code>:尝试加锁，成功返回true，失败返回false</li>
<li><code>void os_unfair_lock_unlock(os_unfair_lock_t lock);</code>:解锁</li>
<li><code>void os_unfair_lock_assert_owner(os_unfair_lock_t lock);</code>:如果当前线程未持有指定的锁，则触发断言</li>
<li><code>void os_unfair_lock_assert_not_owner(os_unfair_lock_t lock);</code>:如果当前线程持有指定的锁，则触发断言</li>
</ul>
<p>各方法同常见的锁没太大差别，可以看下方法注释，只是需要注意一下初始化方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    os_unfair_lock_t unfairLock;</span><br><span class="line">    unfairLock &#x3D; &amp;(OS_UNFAIR_LOCK_INIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="synchronize-object"><a href="#synchronize-object" class="headerlink" title="@synchronize(object)"></a>@synchronize(object)</h3><p><code>@synchronized(object)</code>指令使用传入的对象作为该锁的唯一标识，只有当标识相同时，才满足互斥<br><code>@synchronized(object)</code>指令实现锁的优点就是我们不需要在代码中显式的创建锁对象，便可以实现锁的机制，而且不用担心忘记解锁<br>使用方法极其常见，不做示例了</p>
<h3 id="dispatch-semaphore"><a href="#dispatch-semaphore" class="headerlink" title="dispatch_semaphore"></a>dispatch_semaphore</h3><ul>
<li><code>dispatch_semaphore_t dispatch_semaphore_create(long value);</code>:创建信号量，传入初始值</li>
<li><code>long dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout);</code>:当信号&lt;=0时，根据传入的时间阻塞线程；如果信号&gt;0则不阻塞线程，并对信号-1处理</li>
<li><code>long dispatch_semaphore_signal(dispatch_semaphore_t dsema);</code>:对信号+1处理</li>
</ul>
<p><code>GCD</code>为我们提供的<strong>信号量</strong>也是常用的加锁方式，常见用法是初始化信号值为1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    dispatch_semaphore_t lock &#x3D; dispatch_semaphore_create(1);</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(lock,DISPATCH_TIME_FOREVER);</span><br><span class="line">    &#x2F;&#x2F; 操作</span><br><span class="line">    dispatch_semaphare_signal(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常规操作大家都知道，有常规操作，那么一定也有非常规操作，可以看一下<code>AFNetwork</code>给我们的示范</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">- (NSArray *)tasksForKeyPath:(NSString *)keyPath &#123;</span><br><span class="line">    __block NSArray *tasks &#x3D; nil;</span><br><span class="line">    dispatch_semaphore_t semaphore &#x3D; dispatch_semaphore_create(0);</span><br><span class="line">    [self.session getTasksWithCompletionHandler:^(NSArray *dataTasks, NSArray *uploadTasks, NSArray *downloadTasks) &#123;</span><br><span class="line">        if ([keyPath isEqualToString:NSStringFromSelector(@selector(dataTasks))]) &#123;</span><br><span class="line">            tasks &#x3D; dataTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(uploadTasks))]) &#123;</span><br><span class="line">            tasks &#x3D; uploadTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(downloadTasks))]) &#123;</span><br><span class="line">            tasks &#x3D; downloadTasks;</span><br><span class="line">        &#125; else if ([keyPath isEqualToString:NSStringFromSelector(@selector(tasks))]) &#123;</span><br><span class="line">            tasks &#x3D; [@[dataTasks, uploadTasks, downloadTasks] valueForKeyPath:@&quot;@unionOfArrays.self&quot;];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch_semaphore_signal(semaphore);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line"></span><br><span class="line">    return tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>AFURLSessionManager</code>中，初始化使用<code>dispatch_semaphore_create(0)</code>，在<code>return tasks;</code>前调用<code>dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</code>阻塞线程，待block将目标值赋值后，执行<code>dispatch_semaphore_signal(semaphore);</code>,此时tasks已经有值，线程被唤醒后正常返回。很秀</p>
<h3 id="pthread-mutex"><a href="#pthread-mutex" class="headerlink" title="pthread_mutex"></a>pthread_mutex</h3><p>C语言下的互斥锁方案，是<NSLocking>协议下四个类的底层</p>
<p>锁常用函数：</p>
<ul>
<li><code>pthread_mutex_init</code>:动态初始化互斥量</li>
<li><code>PTHREAD_MUTEX_INITIALIZER</code>:静态创建互斥量</li>
<li><code>pthread_mutex_lock</code>:给一个互斥量加锁</li>
<li><code>pthread_mutex_trylock</code>:加锁，如果失败不阻塞</li>
<li><code>pthread_mutex_unlock</code>:解锁</li>
<li><code>pthread_mutex_destroy</code>:销毁锁</li>
</ul>
<p>参数配置函数：</p>
<ul>
<li><code>pthread_mutexattr_init</code>:初始化参数</li>
<li><code>pthread_mutexattr_settype</code>:设置类型</li>
<li><code>pthread_mutexattr_setpshared</code>:设置作用域</li>
<li><code>pthread_mutexattr_destroy</code>:销毁参数</li>
</ul>
<p>条件常见函数：</p>
<ul>
<li><code>pthread_cond_init</code>:动态初始化条件量</li>
<li><code>PTHREAD_COND_INITIALIZER</code>:静态创建条件量</li>
<li><code>pthread_cond_wait</code>:传入条件量及锁</li>
<li><code>pthread_cond_signal</code>:唤醒单条线程并加锁</li>
<li><code>pthread_cond_broadcast</code>:广播唤醒所有线程</li>
<li><code>pthread_cond_destroy</code>:销毁条件</li>
</ul>
<p><strong>以上函数都是有返回值的，需要注意的是，若成功则返回0，否则返回错误编号，不是我们习惯中的成功YES失败NO</strong></p>
<p>锁类型：</p>
<ul>
<li><code>PTHREAD_MUTEX_NORMAL</code>:缺省值，这种类型的互斥锁不会自动检测死锁。如果一个线程试图对一个互斥锁重复锁定，将会引起这个线程的死锁。如果试图解锁一个由别的线程锁定的互斥锁会引发不可预料的结果。如果一个线程试图解锁已经被解锁的互斥锁也会引发不可预料的结果</li>
<li><code>PTHREAD_MUTEX_ERRORCHECK</code>:这种类型的互斥锁会自动检测死锁。如果一个线程试图对一个互斥锁重复锁定，将会返回一个错误代码。如果试图解锁一个由别的线程锁定的互斥锁将会返回一个错误代码。如果一个线程试图解锁已经被解锁的互斥锁也将会返回一个错误代码</li>
<li><code>PTHREAD_MUTEX_RECURSIVE</code>:如果一个线程对这种类型的互斥锁重复上锁，不会引起死锁，一个线程对这类互斥锁的多次重复上锁必须由这个线程来重复相同数量的解锁，这样才能解开这个互斥锁，别的线程才能得到这个互斥锁。如果试图解锁一个由别的线程锁定的互斥锁将会返回一个错误代码。如果一个线程试图解锁已经被解锁的互斥锁也将会返回一个错误代码。这种类型的互斥锁只能是进程私有的（作用域属性PTHREAD_PROCESS_PRIVATE）</li>
<li><code>PTHREAD_MUTEX_DEFAULT</code>:就是NORMAL类型</li>
</ul>
<p>锁作用域：</p>
<ul>
<li><code>PTHREAD_PROCESS_PRIVATE</code>:缺省值，作用域为进程内</li>
<li><code>PTHREAD_PROCESS_SHARED</code>:作用域为进程间</li>
</ul>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">static pthread_mutex_t c_lock;</span><br><span class="line">- (void)testPthread_mutex &#123;</span><br><span class="line">    pthread_mutexattr_t c_lockAttr;</span><br><span class="line">    pthread_mutexattr_init(&amp;c_lockAttr);</span><br><span class="line">    pthread_mutexattr_settype(&amp;c_lockAttr, PTHREAD_MUTEX_RECURSIVE);</span><br><span class="line">    pthread_mutexattr_setpshared(&amp;c_lockAttr, PTHREAD_PROCESS_PRIVATE);</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_init(&amp;c_lock, &amp;c_lockAttr);</span><br><span class="line">    pthread_mutexattr_destroy(&amp;c_lockAttr);</span><br><span class="line"></span><br><span class="line">    pthread_t thread1;</span><br><span class="line">    pthread_create(&amp;thread1, NULL, _thread1, NULL);</span><br><span class="line">    </span><br><span class="line">    pthread_t thread2;</span><br><span class="line">    pthread_create(&amp;thread2, NULL, _thread2, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *_thread1() &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c_lock);</span><br><span class="line">    printf(&quot;thread 1\n&quot;);</span><br><span class="line">    pthread_mutex_unlock(&amp;c_lock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void *_thread2() &#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c_lock);</span><br><span class="line">    printf(&quot;thread 2 busy\n&quot;);</span><br><span class="line">    sleep(3);</span><br><span class="line">    printf(&quot;thread 2\n&quot;);</span><br><span class="line">    pthread_mutex_unlock(&amp;c_lock);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用锁的注意点"><a href="#使用锁的注意点" class="headerlink" title="使用锁的注意点"></a>使用锁的注意点</h2><ol>
<li><p>互斥量需要时间来加锁和解锁。锁住较少互斥量的程序通常运行得更快。所以，互斥量应该尽量少，够用即可，每个互斥量保护的区域应则尽量大。</p>
</li>
<li><p>互斥量的本质是串行执行。如果很多线程需要领繁地加锁同一个互斥量，<br>则线程的大部分时间就会在等待，这对性能是有害的。如果互斥量保护的数据(或代码)包含彼此无关的片段，则可以特大的互斥量分解为几个小的互斥量来提高性能。这样，任意时刻需要小互斥量的线程减少，线程等待时间就会减少。所以，互斥量应该足够多(到有意义的地步)，每个互斥量保护的区域则应尽量的少。</p>
</li>
</ol>
<h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><blockquote>
<p><a href="https://www.xuebuyuan.com/3121962.html" target="_blank" rel="noopener">Posix互斥量pthread_mutex_t</a><br><a href="https://www.jianshu.com/p/ddbe44064ca4" target="_blank" rel="noopener">iOS 常见知识点（三）：Lock</a><br><a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="noopener">不再安全的 OSSpinLock</a><br><a href="https://stackoverflow.com/questions/1215330/how-does-synchronized-lock-unlock-in-objective-c/6047218#6047218" target="_blank" rel="noopener">How does @synchronized lock/unlock in Objective-C?</a><br><a href="https://www.jianshu.com/p/7288eacbb1a2" target="_blank" rel="noopener">[爆栈热门 iOS 问题] atomic 和 nonatomic 有什么区别？</a><br><a href="">《高性能iOS应用开发中文版》</a></p>
</blockquote>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"># iOS</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/11/21/%E9%81%97%E6%86%BE%E4%B8%8E%E5%B8%8C%E6%9C%9B/" rel="next" title="遗憾与希望">
                <i class="fa fa-chevron-left"></i> 遗憾与希望
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Tr2e</p>
              <p class="site-description motion-element" itemprop="description">Principle & Order</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#前言"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引子"><span class="nav-number">2.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何使用锁"><span class="nav-number">3.</span> <span class="nav-text">如何使用锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#"><span class="nav-number">3.1.</span> <span class="nav-text"></span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#NSLock"><span class="nav-number">3.1.1.</span> <span class="nav-text">NSLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSConditionLock"><span class="nav-number">3.1.2.</span> <span class="nav-text">NSConditionLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSRecursiveLock"><span class="nav-number">3.1.3.</span> <span class="nav-text">NSRecursiveLock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NSCondition"><span class="nav-number">3.1.4.</span> <span class="nav-text">NSCondition</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSSpinLock"><span class="nav-number">3.2.</span> <span class="nav-text">OSSpinLock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#os-unfair-lock"><span class="nav-number">3.3.</span> <span class="nav-text">os_unfair_lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#synchronize-object"><span class="nav-number">3.4.</span> <span class="nav-text">@synchronize(object)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dispatch-semaphore"><span class="nav-number">3.5.</span> <span class="nav-text">dispatch_semaphore</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#pthread-mutex"><span class="nav-number">3.6.</span> <span class="nav-text">pthread_mutex</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用锁的注意点"><span class="nav-number">4.</span> <span class="nav-text">使用锁的注意点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考文档"><span class="nav-number">5.</span> <span class="nav-text">参考文档</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Tr2e</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
